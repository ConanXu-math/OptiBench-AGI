{
  "paper_name": "Optimisation of the lowest Robin eigenvalue in the exterior of a compact set",
  "arxiv_id": "1608.04896v2",
  "outline": {
    "objective": "\\max_{\\Omega \\text{ convex}, |\\partial\\Omega|=c_1} \\lambda^{\\alpha}_1(\\Omega_{ext}) = \\lambda^{\\alpha}_1((B^{\text{R}}_{R_1})_{ext})",
    "constraints": [
      "|∫_{\\partial\\Omega}| = c_1",
      "|∫_{\\Omega}| = c_2"
    ],
    "variables": [
      "\\Omega",
      "c_1",
      "c_2",
      "\\alpha"
    ],
    "notation_table": [
      {
        "symbol": "\\Sigma",
        "dimension": "1-dimensional Hausdorff measure",
        "description": "Boundary of domain \\Omega (in R^2)"
      },
      {
        "symbol": "|\\partial\\Omega|",
        "dimension": "length",
        "description": "Perimeter of domain \\Omega"
      },
      {
        "symbol": "|\\Omega|",
        "dimension": "area",
        "description": "Area of domain \\Omega"
      },
      {
        "symbol": "c_1",
        "dimension": "length",
        "description": "Constant perimeter constraint (positive real)"
      },
      {
        "symbol": "c_2",
        "dimension": "area",
        "description": "Constant area constraint (positive real)"
      },
      {
        "symbol": "\\alpha",
        "dimension": "real number",
        "description": "Real parameter for Robin boundary conditions (negative)"
      },
      {
        "symbol": "\\Omega_{ext}",
        "dimension": "open set",
        "description": "The exterior domain: \\mathbb{R}^2 \\setminus \\Omega"
      },
      {
        "symbol": "\\lambda^{\\alpha}_1(\\Omega_{ext})",
        "dimension": "eigenvalue",
        "description": "Lowest eigenvalue of the Robin Laplacian on \\Omega_{ext}"
      },
      {
        "symbol": "B^{\text{R}}_{R_1}",
        "dimension": "disk in R^2",
        "description": "Disk with perimeter equal to |∫_Θ| = c_1"
      },
      {
        "symbol": "B^{\text{R}}_{R_2}",
        "dimension": "disk in R^2",
        "description": "Disk with area equal to |∫_Θ| = c_2"
      }
    ]
  },
  "prove_cot": "",
  "pseudocode": "BEGIN\n\tGenerate synthetic data with fixed perimeter c1 and area c2 constraints.\n\tDefine objective function that approximates eigenvalue λ^α₁(Ω_ext) using ellipse parameters [a, b].\n\tApply penalties if perimeter or area deviate from c1/c2.\n\tUse scipy.optimize.minimize to maximize eigenvalue (via minimizing negative value).\n\tReturn optimal_value and solution [a, b].\nEND",
  "pycode": "import numpy as np\nfrom scipy.optimize import minimize\n\ndef robin_eigenvalue_approx(shape_params, c1, c2, alpha):\n    \"\"\"Approximates lowest Robin eigenvalue λ₁^(α)(Ω_ext) for given shape parameters.\"\"\"\n    a, b = shape_params\n    \n    # Ensure positive axes\n    if a <= 0 or b <= 0:\n        return float('-inf')\n    \n    # Compute perimeter and area of ellipse (approximations)\n    perimeter = 4 * a * np.arcsin(np.sqrt((a**2 + b**2) / (2 * a * b))) if a == b else 2 * np.pi * np.sqrt((a**2 + b**2)/2)\n    area = np.pi * a * b\n    \n    # Penalization if constraints violated\n    perim_penalty = max(0, abs(perimeter - c1)) * 1e6\n    area_penalty = max(0, abs(area - c2)) * 1e6\n    \n    # Simple heuristic for eigenvalue\n    gamma = 1.0 + 0.1 * a / b\n    eigenval_heuristic = gamma / (a ** 2 + b ** 2) if (a*b) > 0 else float('-inf')\n    \n    # Return objective (to be maximized => negate for minimizer)\n    total_cost = -eigenval_heuristic + perim_penalty + area_penalty\n    return total_cost\n\ndef generate_synthetic_data(seed=42) -> dict:\n    \"\"\"Generate synthetic data with feasible constraints.\"\"\"\n    np.random.seed(seed)\n    \n    # Feasible values\n    c1 = 10.0  # perimeter constraint\n    c2 = 6.0   # area constraint\n    alpha = -0.5  # negative Robin parameter\n    \n    # Initialize with feasible starting point\n    a_guess = 2.5\n    b_guess = c2 / (np.pi * a_guess)  # ensure π*a*b ≈ c2\n    \n    return {\n        'c1': c1,\n        'c2': c2,\n        'alpha': alpha,\n        'a0': a_guess,\n        'b0': b_guess\n    }\n\ndef solve(data: dict) -> dict:\n    \"\"\"Solve optimization problem using scipy.optimize.minimize.\"\"\"\n    c1, c2, alpha = data['c1'], data['c2'], data['alpha']\n    \n    x0 = [data['a0'], data['b0']]  # ellipse parameters [a, b]\n    bounds = [(0.1, 10), (0.1, 10)]  # avoid singular shapes\n    \n    def objective(x):\n        return robin_eigenvalue_approx(x, c1, c2, alpha)\n    \n    result = minimize(\n        fun=objective,\n        x0=x0,\n        bounds=bounds,\n        method='SLSQP',\n        options={'disp': True, 'ftol': 1e-8}\n    )\n    \n    if not result.success:\n        raise ValueError(f\"Optimization failed: {result.message}\")\n    \n    optimal_value = -result.fun\n    solution = result.x\n    \n    return {\n        'optimal_value': optimal_value,\n        'solution': solution,\n        'status': result.success,\n        'message': result.message\n    }\n\nif __name__ == '__main__':\n    data = generate_synthetic_data()\n    print(\"Generated Data:\")\n    for k, v in data.items():\n        print(f\"{k}: {v}\")\n    \n    solution = solve(data)\n    print(f\"Optimization Result:\\nOptimal Value: {solution['optimal_value']:.4f}\\nSolution (a, b): {solution['solution']}\\nSuccess: {solution['status']}\"')",
  "lean4_formal": ""
}